// Giovanni Acireale, 9/21/24, Assignment 2: Magic Leak Detection

#include <stdio.h>
#include <stdlib.h>

#define MAXN 2000  // Maximum grid size

// Struct to represent a point in the grid
typedef struct {
    int x, y;
} Point;

// Global variables for grid dimensions, grid data, and region tracking
int R, C;
char** grid;           // 2D array to store the grid
int** region;          // 2D array to store the region IDs for each point
int* region_size;      // Array to store the size of each region
long long* region_magic; // Array to store the magic generated by each region

// Directions for moving up, down, left, or right
int directions[4][2] = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };

// Function to check if a position (x, y) is valid within the grid
int is_valid_position(int x, int y) {
    return (x >= 0 && x < R && y >= 0 && y < C);
}

// Function to perform flood-fill from a starting point (start_x, start_y)
// and assign a unique region ID to all connected free points ('.')
void flood_fill(int start_x, int start_y, int region_id) {
    // Allocate a queue for the flood-fill algorithm
    Point* queue = (Point*)malloc(R * C * sizeof(Point));
    if (!queue) {  // Check for memory allocation failure
        printf("Memory allocation failed for queue\n");
        exit(1);
    }

    // Initialize the queue for flood fill
    int front = 0, back = 0;
    queue[back++] = (Point){ start_x, start_y };  // Add the starting point to the queue
    region[start_x][start_y] = region_id;  // Assign region ID to the starting point
    int size = 0;  // Initialize the region size

    // Flood-fill loop
    while (front < back) {
        if (back >= R * C) {  // Prevent queue overflow
            printf("Queue overflow detected\n");
            free(queue);
            exit(1);
        }

        Point current = queue[front++];  // Dequeue the current point
        size++;  // Increment region size

        // Explore neighboring points (up, down, left, right)
        for (int i = 0; i < 4; i++) {
            int nx = current.x + directions[i][0];
            int ny = current.y + directions[i][1];

            // If the neighboring point is within bounds and free, add it to the queue
            if (is_valid_position(nx, ny) && grid[nx][ny] == '.' && region[nx][ny] == -1) {
                region[nx][ny] = region_id;  // Mark the point with the current region ID
                queue[back++] = (Point){ nx, ny };  // Enqueue the neighboring point
            }
        }
    }

    free(queue);  // Free the memory allocated for the queue

    // Store the size of the region and calculate the magic generated
    if (region_id < MAXN * MAXN) {
        region_size[region_id] = size;
        region_magic[region_id] = (long long)size * (size + 1) / 2;  // Magic formula
    }
    else {
        printf("Region ID out of bounds\n");
        exit(1);
    }
}

// Main function to read the grid, perform flood-fill, and calculate magic generation
int main() {
    // Read the grid dimensions (R = rows, C = columns)
    scanf("%d %d", &R, &C);

    // Allocate memory for the grid and region arrays
    grid = (char**)malloc(R * sizeof(char*));
    region = (int**)malloc(R * sizeof(int*));
    if (!grid || !region) {
        printf("Memory allocation failed\n");
        return 1;
    }

    for (int i = 0; i < R; i++) {
        grid[i] = (char*)malloc(C * sizeof(char));
        region[i] = (int*)malloc(C * sizeof(int));
        if (!grid[i] || !region[i]) {
            printf("Memory allocation failed for grid[%d] or region[%d]\n", i, i);
            return 1;
        }
    }

    // Allocate memory for region size and magic arrays
    region_size = (int*)malloc(MAXN * MAXN * sizeof(int));
    if (!region_size) {  // Check for memory allocation failure
        printf("Memory allocation failed for region_size\n");
        return 1;
    }

    region_magic = (long long*)malloc(MAXN * MAXN * sizeof(long long));
    if (!region_magic) {  // Check for memory allocation failure
        printf("Memory allocation failed for region_magic\n");
        return 1;
    }

    // Read the grid data (characters representing free points, closed points, or failure points)
    for (int i = 0; i < R; i++) {
        scanf("%s", grid[i]);
    }

    // Initialize the region array to -1 (indicating unvisited points)
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            region[i][j] = -1;
        }
    }

    int current_region = 0;  // Variable to track the current region ID
    long long total_magic = 0;  // Total magic generated

    // Perform flood-fill on each unvisited free point to identify regions
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            if (grid[i][j] == '.' && region[i][j] == -1) {  // Check if it's a free unvisited point
                if (current_region < MAXN * MAXN) {
                    flood_fill(i, j, current_region);  // Perform flood-fill
                    total_magic += region_magic[current_region];  // Accumulate magic
                    current_region++;  // Move to the next region
                }
            }
        }
    }

    long long max_magic = total_magic;  // Initialize max magic with total magic

    // Check every failure point ('X') to find the worst failure scenario
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            if (grid[i][j] == 'X') {  // Check if it's a potential failure point
                long long combined_size = 0;
                long long combined_magic = 0;
                int seen_regions[4] = { -1, -1, -1, -1 };  // Array to track neighboring regions
                int num_seen = 0;

                // Check the 4 neighboring regions
                for (int d = 0; d < 4; d++) {
                    int nx = i + directions[d][0];
                    int ny = j + directions[d][1];

                    if (is_valid_position(nx, ny) && grid[nx][ny] == '.') {  // Check for valid neighbors
                        int neighbor_region = region[nx][ny];

                        // Check if the region has already been processed
                        int already_seen = 0;
                        for (int k = 0; k < num_seen; k++) {
                            if (seen_regions[k] == neighbor_region) {
                                already_seen = 1;
                                break;
                            }
                        }

                        if (!already_seen) {
                            seen_regions[num_seen++] = neighbor_region;  // Mark region as seen
                            combined_size += region_size[neighbor_region];  // Combine region sizes
                            combined_magic += region_magic[neighbor_region];  // Combine region magic
                        }
                    }
                }

                // Calculate the new magic if this point fails and becomes free
                if (combined_size > 0) {
                    combined_size++;  // Add the new free point
                    long long new_magic = (combined_size * (combined_size + 1)) / 2;  // Calculate new magic
                    long long new_total_magic = total_magic - combined_magic + new_magic;
                    if (new_total_magic > max_magic) {
                        max_magic = new_total_magic;  // Update max magic if this failure is worse
                    }
                }
            }
        }
    }

    // Output the maximum magic that can be generated by a single failure
    printf("%lld\n", max_magic);

    // Free dynamically allocated memory for grid, region, region_size, and region_magic
    for (int i = 0; i < R; i++) {
        free(grid[i]);
        free(region[i]);
    }
    free(grid);
    free(region);
    free(region_size);
    free(region_magic);

    return 0;
}
